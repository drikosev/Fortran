
Sep 22, 2018


 
                 Fortran Enhanced LALR BNF Grammar & Lexical Rules
                 -------------------------------------------------



 The Fortran Grammar
 -------------------
 [2018-04-24]
 This grammar is based on a Fortran 2003 draft ("N1601.pdf.gz") and has been transformed as needed to allow an Enhanced LALR Builder (Syntaxis.jar) to process it and create a conflicts-free parser that accepts in addition deprecated Fortran 77 features. Over the time, features of newer drafts have been added as well along with common extensions supported by various vendors.

Eventually, some extensions were defined in a separate grammar ("Legacy_Parser.txt") and later OpenMP extensions in the newer one ("OMP_Legacy_Parser.txt") which is the grammar being extended now on. 

 The transformed grammar is supposed to describe accurately array elements and function references. In other words, it isn't a covering grammar. Further, it is also complete in the sense that we fully parse constructs (e.g. non-block do construct ). In other words, we don't parse one statement at a time.

 However, this grammar accepts declaration and execution constructs in any order, the assumed-shape-spec-list is used also for deferred-shaped arrays, and the section-subscript-list in example could likely be more accurate. It has passed a few tests; yet, bug reports by experienced Fortran programmers are welcome.

 Actually, I had written this grammar to stress test some LALR enhancements and some relevant details were
 originally posted at: http://compilers.iecc.com/comparch/article/13-07-011

 Notes: 
 [1] We use a stack to distinguish between ordinary labels and labels of non-block do constructs. 
 [2] Default actions don't overwrite the reduce actions on keywords "FUNCTION" & "SUBROUTINE" because
     the token "<name-f>" depends on them. In the serialised version of the grammar the directive ie
     "#reductions FUNCTION" indicates exactly this restriction. 
 [3] The syntax notation is almost pure BNF, with "Follow Restrictions" ( "+:", "-:", and "~:") and
     "Error Productions" ("::~"). 
 [4] Definitely this non LR(k) grammar is ambiguous (see users.otenet.gr/~drikosev/miscellaneous.html).
 [5] The ENLALR builder is capable ie to generate a deterministic parser that could parse intrinsic 
     operators without dots in free form Fortran. This includes the intrinsic operator ".not." which
     should split to an intrinsic function that takes an argument and an operator for arguments without
     parentheses.
 [6] The ENLALR parser supports the SMA technique selectively on individual tokens, which is required 
     in our free form Fortran parser, as a "(/" ie is in a format statement a valid sequence of a '(' 
     and a '/' (2018-06-06). The scanners support the directive with an "inversed" logic (2018-09-01).
 [7] One can safely assume that any recent changes in the ChangeLog haven't been tested thoroughly.



 Files
 -----

 1) The Fortran Parser
    1.1) The "Fortran_Parser.txt" contains the syntax rules of the Fortran parser.
    1.2) The "Fortran_Parser.html" has the same content with the "Fortran_Parser.txt" in HTML format.

 2) The Fortran Scanner
    2.1) The "Fortran_Scanner.txt" contains the lexical rules of a Fortran scanner that is shared
         by several Fortran parsers. Now it uses a carriage return ('\r') as a statement terminator. 
         
    2.2) The "Fortran_Scanner.html" has the same content with the "Fortran_Scanner.txt" but in HTML
         format.

 3) A Legacy Parser
    3.1) The "Legacy_Parser.txt" contains the syntax rules of a Fortran parser, which in addition to
         the above mentioned Fortran parser, accepts structures, unions, maps, and records. These
         extensions originate from VAX/DEC Fortran and are supported by the IntelÂ® Fortran Compiler.
         Many of these extensions are also supported by GNU Fortran (ie in version 7). 

         At the moment, this grammar is just informative because one needs to implement semantic 
         actions that can distinguish a dotted operator from members of nested structures. This
         is required in example when the parser sees text of the form "var.op.field". 

         So, this grammar doesn't fail to parse statements of the form "a.b.c=a.b.d;" but without
         the semantic actions mentioned above, the RHS of the assignment is interpreted as an
         expression with two operands, 'a' and 'd', and a user defined dotted operator, ".b.".

         Further, the BNF syntax of these extensions is the result of a personal effort that involves
         some guessing. So, this grammar might not describe fully & accurately real code yet. 

         Again, this is just an informative grammar, without a distinct generated C++ parser yet!

    3.2) The "Legacy_Parser.html" has the same content with the "Legacy_Parser.txt" but in HTML format.


 4) OMP (Legacy) Parser
    -------------------
    [2018-09-22]

    4.1) The "OMP_Legacy_Parser.txt" contains the syntax rules of a Fortran parser, which in addition
         to the above mentioned Fortran (Legacy) parser, is also OpenMP (4.5) compliant.

         Note that the literal "!$OMP", which is parsed by the Hand Coded File Reader, introduces an OMP 
         directive and is also required in both fixed & free form continuation lines; in fixed form also
         "*$OMP" or "c$OMP", always at first column. Whereas the literal "!$" is used for conditional
         compilation. 

         Note also that these syntax rules describe features that needed special handling:
         (a) A ';' isn't allowed as an OMP Directive terminator, which is handled by a semantic action.
         (b) An OMP Directive cannot have a label.
         (c) Optional spacing between keywords in OMP headers/footers but not in clauses (ie private).
             Some OMP keywords are already Fortran keywords, which makes this problem harder. So, there
             is a chance that the parser accepts more optional spaces than it should, always between
             tokens. In alternative, I should create ie one token per OMP header/footer but this would
             make the scanner even larger; please note that this is a free form specific issue.
         (d) Optional OMP END directives after Fortran DO constructs. My solution was one token per 
             optional directive.
         (e) This grammar makes no distinction between update/capture statements in Atomic Constructs.


    4.2) The "OMP_Legacy_Parser.html" has the same content with the "OMP_Legacy_Parser.txt" but in HTML
         format.


 5) OMP Fortran Scanner
    -------------------
    [2018-08-27]

    5.1) The "OMP_Fortran_Scanner.txt" contains the lexical rules of the Fortran scanner that is used
         by the  OMP (Legacy) Parser. 
         
         This scanner uses a carriage return ('\r') as a statement terminator. Such a change however
         has various implications. Several corner cases, ie "do5i=1,2", haven't been tested very well.

    5.2) The "OMP_Fortran_Scanner.html" has the same content with the "OMP_Fortran_Scanner.txt" but in
         HTML format.


 6) Format Parser
    -------------
    [2018-09-02]

    6.1) The "format-parser.txt" contains the syntax rules of the Format Specification string.
         (a) It's an embedded parser currently called in a '<print-stmt>' by the function 'onPrint'. 
         (b) The following 3 lines show how it's been linked in the grammar "OMP_Legacy_Parser.txt": 
             <print-stmt> ::= 
                 |     PRINT <format>                          /*Tr.onPrint($$(0),$$(2)); */
                 |     PRINT <format> <,> <output-item-list>   /*Tr.onPrint($$(0),$$(2),$$(4)); */
 
         (c) Embedding in the Translator a fully functional generated parser to validate a format
             string that usually has less than 10 characters may be superfluous. Yet, one goal of
             this project is to demonstrate the capabilities of "Syntaxis". 

    6.2) The "format-parser.html" has the same content with the "format-parser.txt" in HTML format.


 7) Format Scanner
    --------------
    [2018-09-02]
    7.1) The "format-scanner.txt" contains the lexical rules used in the Format Specification string. 
    7.2) The "format-scanner.html" has the same content with the "format-scanner.txt" in HTML format.


 8) ChangeLog
    8.1) The file "ChangeLog" contains known or solved bugs along with various supported extensions.

